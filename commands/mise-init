#!/home/mcrowe/.local/share/mise/installs/python/3.12.11/bin/python3

import json
import os
import re
import sys
from pathlib import Path

import toml
import tomli_w
from textual import on
from textual.app import App, ComposeResult
from textual.containers import Horizontal, Vertical
from textual.events import Mount
from textual.widgets import Button, Footer, Header, Markdown, RichLog, SelectionList
from textual.widgets.selection_list import Selection

TEMPLATE_DIR = Path(__file__).parent.parent / "templates/mise-tools"
DEBUG = len(sys.argv) > 1 and sys.argv[1] == "debug"
templates = [(f.stem, f) for f in sorted(TEMPLATE_DIR.glob("*.toml"))]


class MyToml:
    def __init__(self, path: Path, text_log: RichLog):
        self.path = path
        self.content = {}
        self.header = []
        if self.path.exists():
            self.load()
        self.text_log = text_log

    def load(self):
        lines = open(self.path).read().splitlines()
        section_name = None
        section = None
        for line in lines:
            if line.startswith("["):
                section_name = line.strip()
                self.content[section_name] = {
                    "lines": [],
                    "items": {},
                    "using": None,
                }
                section = self.content[section_name]
            elif not section_name:
                if line.strip():
                    self.header.append(line)
            elif not section:
                raise Exception(f"Section {section_name} not found")
            elif line.strip():
                if section_name.startswith("[tasks."):
                    section["lines"].append(line)
                    section["using"] = "lines"
                else:
                    section["using"] = "items"
                    parts = re.split(r" *= *", line.strip(), maxsplit=1)
                    if len(parts) == 2:
                        if parts[1].startswith("["):
                            t = toml.loads(parts[1])
                            parts[1] = list(t.keys())
                        self.content[section_name]["items"][parts[0]] = parts[1]
                        self.content[section_name]["using"] = "items"

    def save(self):
        with open(self.path, "w") as f:
            f.write(str(self))

    def merge(self, other: "MyToml"):
        for key_wrapped, value in other.content.items():
            key = re.sub(r"^\[(.*)\]$", r"\1", key_wrapped)
            if key not in self.content:
                self.content[key] = value
                continue
            self.content.setdefault(key, {})
            count = 0
            if value["using"] == "lines":
                lines = self.content[key].setdefault("lines", [])
                lines.clear()
                lines.extend(value["lines"])
                count = len(value["lines"])
            else:
                items = self.content[key].setdefault("items", {})
                for k, v in value["items"].items():
                    current = items.get(k)
                    if isinstance(v, list):
                        if not current or not isinstance(current, list):
                            current = []
                        for list_item in v:
                            if list_item not in current:
                                current.append(list_item)
                    else:
                        current = v
                    items[k] = current
                    count += 1
            self.text_log.write(
                f"Merged {count} items from {key_wrapped} items and {value['using']} lines"
            )

    def section_to_str(self, section_name: str) -> str:
        lines = [f"[{section_name}]"]
        value = self.content[section_name]
        if value["using"] == "lines":
            for line in self.content[section_name]["lines"]:
                lines.append(line)
        else:
            for k, v in self.content[section_name]["items"].items():
                if isinstance(v, list):
                    lines.append(f"{k} = {json.dumps(v, indent=2)}")
                else:
                    lines.append(f"{k} = {v}")
        return "\n".join(lines) + "\n"

    def __str__(self):
        lines = []
        for key in self.content.keys():
            lines.append(self.section_to_str(key))
        return "\n".join(lines)


class TemplateSelections(SelectionList):
    def __init__(self, *args, **kwargs) -> None:
        selections = [Selection(f[0], f[1]) for f in templates]
        super().__init__(*selections, *args, **kwargs)


class MiseInitApp(App):
    CSS_PATH = "mise-init.tcss"
    selected = []
    mise_path = None

    def compose(self) -> ComposeResult:
        self.md = Markdown(id="preview", markdown="")
        self.md.styles.height = "100%"
        self.text_log = RichLog(id="text-log")
        yield Header()
        with Vertical(id="main-container"):
            with Horizontal(id="selection-container"):
                yield TemplateSelections(id="selection")
                yield self.md
            with Horizontal(id="buttons-container"):
                yield Button("Build", id="build", variant="primary")
                yield Button("Quit", id="quit", variant="primary")
            yield self.text_log
        yield Footer()

    def load_mise_toml(self):
        self.mise_path = Path(os.getcwd()) / ".mise.toml"
        if not self.mise_path.exists():
            self.mise_path = Path(os.getcwd()) / "mise.toml"
        self.mise_toml = MyToml(self.mise_path, self.text_log)
        self.text_log.write(f"Loaded {self.mise_path}")

    def on_button_pressed(self, event: Button.Pressed) -> None:
        if event.button.id == "build":
            self.text_log.write("Building and saving...")
            self.handle_build()
        elif event.button.id == "quit":
            self.exit()

    def build_toml_preview(self):
        self.text_log.write("Building preview...")
        self.md.update(
            f"""```toml\n
{str(self.mise_toml)}
```"""
        )

    @on(Mount)
    @on(TemplateSelections.SelectedChanged)
    def update_selected_view(self) -> None:
        self.text_log.write("Updating selected view...")
        self.load_mise_toml()
        self.selected = self.query_one(SelectionList).selected
        if self.selected:
            for tmpl_path in self.selected:
                self.text_log.write(f"Adding {tmpl_path}...")
                template_toml = MyToml(tmpl_path, self.text_log)
                self.mise_toml.merge(template_toml)
        self.build_toml_preview()

    def handle_build(self):
        self.mise_toml.save()


if __name__ == "__main__":
    MiseInitApp().run()
